# Задача 5: chuck_allocator

### Условие:
Требуется реализовать кастомный аллокатор, интерфейс которого схож с интерфейсом std::allocator. Итак, ваш аллокатор должен выделять большой чанк памяти (определите соответствующий вспомогательный класс) при первом запросе на аллокацию. При последующих запросах на аллокацию – необходимо выдавать блоки из этого чанка. Если на какой-то запрос аллокации не выходит выделить блок достаточного размера из чанка – вам необходимо попытаться выделить новый чанк (но только при условии что запрашиваемое количество байт не превышает размер чанка). Чанки стоит связать в список, сохраняя pointer на предыдущий. Это удобно, так как в таком случае при запросе аллокации вы будете итерироваться по всем чанкам, пытаясь найти и выделить требуемый блок, таким образом фрагментация памяти будет слабой. При запросе на деалокацию – ничего не нужно делать, зато удалять саму память надо в деструкторе. Очень важно предусмотреть возможность копирования вашего аллокатора, ведь если не обработать этот случай специально – вы словите глупую ошибку с двойным удалением памяти. Вместо этого – нужно ввести счетчик "потребителей", то есть счетчик инстансов вашего класса, которые выделяют память через него. Подробнее условие я объяснил в [видео](https://youtu.be/q-bR0Jgciks) на своем YouTube канале.

Ваш класс должен быть STL-совместимым, то есть позволять использование в качестве аллокатора для контейнеров STL. Должны быт реализованы методы:
- Конструктор по-умолчанию
- Конструктор копирования
- Деструктор
- Оператор =
- Метод allocate
- Метод deallocate
- Метод construct
- Метод destoy
- Нужно также задать члены-типы: value_type, pointer, const_pointer, reference, const_reference, size_type, difference_type, rebind. Их сделайте по аналогии с std::allocator.

Полезно смотреть [сюда](https://en.cppreference.com/w/cpp/memory/allocator).



##### Стоимость:
Задача стоит 7 баллов.


##### Срок сдачи:
Решения сданные позже 23:59:59 20 Октября 2020 года не принимаются.

